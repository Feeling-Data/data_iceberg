<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Timeline with Nose Control + Snow Noise</title>

  <!-- D3 -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>
  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/p5.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.2/addons/p5.dom.min.js"></script>
  <!-- ml5.js (PoseNet) -->
  <script src="https://unpkg.com/ml5@0.12.2/dist/ml5.min.js"></script>

  <style>
    body {
      background-color: black;
      color: white;
      font-family: Arial, sans-serif;
    }

    .event {
      stroke-width: 0.5px;
    }

    .axis text {
      font-size: 10px;
      fill: white;
    }

    .x-axis path,
    .x-axis line {
      stroke: white;
    }

    .type-bound {
      pointer-events: none;
      opacity: 0.7;
    }
  </style>
</head>

<body>
  <h2>data_ iceberg (Nose-Controlled Time Range)</h2>
  <div id="scroll-container" style="width: 100%; overflow-x: auto;">
    <svg id="timeline" height="400"></svg>
  </div>

  <script>
    let withLocation = [], withoutLocation = [];
    let xScale, g, startDate, endDate;
    let axisY = 4, rectHeight = 2, verticalPadding = 1;
    let aboveOffsetPadding = 10, belowOffsetPadding = 20;

    const snowCanvas = document.createElement("canvas");
    const snowCtx = snowCanvas.getContext("2d");
    snowCanvas.width = 200;
    snowCanvas.height = 60;

    function updateSnowNoise() {
      const w = snowCanvas.width;
      const h = snowCanvas.height;
      const imageData = snowCtx.createImageData(w, h);

      const blockSize = 6;
      const now = Date.now() * 0.001;

      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const blockX = Math.floor(x / blockSize);
          const blockY = Math.floor(y / blockSize);

          const graySeed = Math.sin(blockX * 12.9898 + blockY * 78.233 + now) * 43758.5453;
          const gray = Math.floor((graySeed - Math.floor(graySeed)) * 255);

          const noise = gray + Math.random() * 20 - 10;

          const i = (y * w + x) * 4;
          imageData.data[i] = noise;
          imageData.data[i + 1] = noise;
          imageData.data[i + 2] = noise;
          imageData.data[i + 3] = 120;
        }
      }

      // bold line (per 2 line)
      for (let y = 0; y < h; y += 2) {
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;
          imageData.data[i] *= 0.3;
          imageData.data[i + 1] *= 0.3;
          imageData.data[i + 2] *= 0.3;
        }
      }

      // thin line
      for (let y = 0; y < h; y++) {
        for (let x = 0; x < w; x++) {
          const i = (y * w + x) * 4;
          const fade = 0.98 + 0.02 * Math.sin(y * 0.5); // add vibrant
          imageData.data[i] *= fade;
          imageData.data[i + 1] *= fade;
          imageData.data[i + 2] *= fade;
        }
      }

      snowCtx.putImageData(imageData, 0, 0);
      const dataURL = snowCanvas.toDataURL("image/png");
      d3.select("#snownoise-image").attr("xlink:href", dataURL);
    }


    setInterval(updateSnowNoise, 100); // dynamic noise

    fetch("data.json")
      .then(res => res.json())
      .then(data => {
        const parseDate = d3.timeParse("%d/%m/%Y");
        const cleanedData = data
          .map(d => {

            if (!d.date || typeof d.date !== 'string') return null;

            const cleanedDateStr = d.date.replace(/\\\//g, "/");
            const parsedDate = parseDate(cleanedDateStr);

            if (!parsedDate) return null;

            const monthObj = new Date(parsedDate.getFullYear(), parsedDate.getMonth(), 1);
            return { ...d, dateObj: parsedDate, monthObj };
          })
          .filter(d => d !== null);

        withLocation = cleanedData.filter(d => d.Extracted_Locations);
        withoutLocation = cleanedData.filter(d => !d.Extracted_Locations);

        if (cleanedData.length === 0) {
          console.error("No valid date data found");
          return;
        }

        const minDate = d3.min(cleanedData, d => d.monthObj);
        const maxDate = d3.max(cleanedData, d => d.monthObj);

        startDate = d3.timeMonth.offset(minDate, -1);
        endDate = d3.timeMonth.offset(maxDate, 1);

        const totalMonths = d3.timeMonth.count(startDate, endDate);
        const pixelsPerMonth = 50; // Increased from daily to monthly scale
        const svgWidth = totalMonths * pixelsPerMonth;

        const svg = d3.select("#timeline").attr("width", svgWidth);
        const defs = svg.append("defs");

        // dynamic noise pattern
        const pattern = defs.append("pattern")
          .attr("id", "snownoise-pattern")
          .attr("patternUnits", "userSpaceOnUse")
          .attr("width", 200)
          .attr("height", 60);

        pattern.append("image")
          .attr("id", "snownoise-image")
          .attr("width", 200)
          .attr("height", 60)
          .attr("x", 0)
          .attr("y", 0);

        const margin = { top: 40, right: 20, bottom: 40, left: 50 };
        const width = svgWidth - margin.left - margin.right;
        g = svg.append("g").attr("transform", `translate(${margin.left},${margin.top})`);

        xScale = d3.scaleTime().domain([startDate, endDate]).range([0, width]);
        const xAxis = d3.axisBottom(xScale).ticks(d3.timeMonth.every(1)).tickFormat(d3.timeFormat("%b %Y"));

        // Group data by month for counting
        const withLocationByMonth = d3.rollup(withLocation, v => v.length, d => +d.monthObj);
        const withoutLocationByMonth = d3.rollup(withoutLocation, v => v.length, d => +d.monthObj);

        const maxAbove = d3.max(withLocationByMonth.values());
        const maxBelow = d3.max(withoutLocationByMonth.values());

        const topSpace = maxAbove * (rectHeight + verticalPadding);
        const bottomSpace = maxBelow * (rectHeight + verticalPadding);
        const separationPadding = 100;
        const axisHeightPadding = 60;
        axisY = separationPadding + topSpace + axisHeightPadding;
        const dynamicHeight = axisY + bottomSpace + separationPadding;

        svg.attr("height", dynamicHeight + margin.top + margin.bottom);

        g.append("g")
          .attr("class", "x-axis")
          .attr("transform", `translate(0,${axisY})`)
          .call(xAxis);
      });

    function drawClusterRects(dataArray, yFunc, fillStyle) {
      const typeGroups = new Map();

      // group, by type and month
      const groupedData = d3.rollup(
        dataArray,
        v => v,
        d => d.type1_cluster || "undefined",
        d => +d.monthObj
      );

      // draw all rect and record the position
      groupedData.forEach((monthMap, type) => {
        const typePositions = [];

        monthMap.forEach((items, monthTime) => {
          const monthDate = new Date(monthTime);
          const x = xScale(monthDate);

          // draw rect in certain type
          items.forEach((d, i) => {
            const y = yFunc(d);
            g.append("rect")
              .attr("x", x)
              .attr("y", y)
              .attr("width", 10)
              .attr("height", rectHeight)
              .attr("fill", fillStyle)
              .append("title")
              .text(`${d.title} (${d.date})`);

            typePositions.push({ x, y });
          });
        });

        // build a box for one type
        if (typePositions.length > 0) {
          const xs = typePositions.map(p => p.x);
          const ys = typePositions.map(p => p.y);

          const padding = 0.5;
          const minX = d3.min(xs) - padding;
          const maxX = d3.max(xs) + 10 + padding;
          const minY = d3.min(ys) - padding;
          const maxY = d3.max(ys) + rectHeight + padding;

          // draw box
          g.append("rect")
            .attr("x", minX)
            .attr("y", minY)
            .attr("width", maxX - minX)
            .attr("height", maxY - minY)
            .attr("stroke", "white")
            .attr("stroke-width", 0.5)
            .attr("fill", "none")
            .attr("class", "type-bound");

          g.append("text")
            .attr("x", maxX + 4)
            .attr("y", minY + 6)
            .attr("fill", "white")
            .attr("font-size", "7px")
            .attr("text-anchor", "start")
            .text(type);
        }
      });
    }
    function updateVisibleData(noseX) {
      if (!xScale || !g || !startDate || !endDate) return;

      const percent = 1 - Math.min(Math.max(noseX / videoWidth, 0), 1);
      const windowMonths = 1; // Show 1 month at a time
      const fullRange = endDate - startDate;
      const centerTimeRaw = new Date(+startDate + percent * fullRange);

      let from = d3.timeMonth.offset(centerTimeRaw, -windowMonths / 2);
      let to = d3.timeMonth.offset(centerTimeRaw, windowMonths / 2);
      if (from < startDate) {
        from = startDate;
        to = d3.timeMonth.offset(from, windowMonths);
      }
      if (to > endDate) {
        to = endDate;
        from = d3.timeMonth.offset(to, -windowMonths);
      }

      const visibleWith = withLocation
        .filter(d => d.monthObj >= from && d.monthObj <= to)
        .sort((a, b) => {
          if (a.monthObj - b.monthObj !== 0) return a.monthObj - b.monthObj;
          return (a.type1_cluster || "").localeCompare(b.type1_cluster || "");
        });

      const visibleWithout = withoutLocation
        .filter(d => d.monthObj >= from && d.monthObj <= to)
        .sort((a, b) => {
          if (a.monthObj - b.monthObj !== 0) return a.monthObj - b.monthObj;
          return (a.type1_cluster || "").localeCompare(b.type1_cluster || "");
        });

      g.selectAll("*").remove();

      // Axis again after clearing
      const xAxis = d3.axisBottom(xScale).ticks(d3.timeMonth.every(1)).tickFormat(d3.timeFormat("%b %Y"));
      g.append("g")
        .attr("class", "x-axis")
        .attr("transform", `translate(0,${axisY})`)
        .call(xAxis);

      // Offset tracking
      const aboveOffsetMap = {};
      const belowOffsetMap = {};

      function getOffset(monthObj, map) {
        const key = +monthObj;
        if (!map[key]) map[key] = 0;
        return map[key]++;
      }

      // Draw grouped rects
      drawClusterRects(
        visibleWith,
        d => axisY - 30 - (getOffset(d.monthObj, aboveOffsetMap) + 1) * (rectHeight + verticalPadding),
        "white"
      );

      drawClusterRects(
        visibleWithout,
        d => axisY + 30 + getOffset(d.monthObj, belowOffsetMap) * (rectHeight + verticalPadding),
        "url(#snownoise-pattern)"
      );
    }

  </script>

  <script>
    let video, poseNet;
    let noseX = null, noseY = null;
    let noseXHistory = [], noseYHistory = [];
    const SMOOTHING_WINDOW = 10;

    const videoWidth = 200;
    const videoHeight = 150;

    function setup() {
      createCanvas(videoWidth, videoHeight).position(window.innerWidth - videoWidth - 10, 600);

      video = createCapture(VIDEO);
      video.size(videoWidth, videoHeight);
      video.hide();

      poseNet = ml5.poseNet(video, () => {
        console.log("PoseNet ready");
        poseNet.on("pose", function (poses) {
          if (poses.length > 0) {
            const nose = poses[0].pose.keypoints.find(k => k.part === "nose");
            if (nose && nose.score > 0.5) {
              noseXHistory.push(nose.position.x);
              noseYHistory.push(nose.position.y);

              if (noseXHistory.length > SMOOTHING_WINDOW) noseXHistory.shift();
              if (noseYHistory.length > SMOOTHING_WINDOW) noseYHistory.shift();

              noseX = noseXHistory.reduce((a, b) => a + b, 0) / noseXHistory.length;
              noseY = noseYHistory.reduce((a, b) => a + b, 0) / noseYHistory.length;
            }
          }
        });
      });
    }

    function draw() {
      background(255);
      image(video, 0, 0, videoWidth, videoHeight);

      if (noseX !== null && noseY !== null) {
        fill(255, 0, 0);
        noStroke();
        ellipse(noseX, noseY, 5, 5);
        updateVisibleData(noseX);
      } else {
        if (g) g.selectAll("rect").remove();
      }
    }
  </script>
</body>

</html>